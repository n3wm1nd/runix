# Runix Task Generation Instructions for LLMs

This document provides instructions for Large Language Models (LLMs) to generate well-structured Runix tasks. Follow these guidelines to create maintainable, composable, and type-safe task implementations that work with the Runix trusted repository system.

## Core Principles

1. **Simplicity First**: Keep the main task function simple and readable
2. **Type Safety**: Use Haskell's type system to prevent runtime errors  
3. **Composition**: Reuse existing packages rather than reimplementing functionality
4. **Clear Interfaces**: Make parameter and result types self-documenting
5. **Standard Tools**: Use standard .cabal files and Haskell project structure

## Task Structure Template

```
task-name/
├── task-name.cabal              # Standard Cabal file (metadata & dependencies)
├── flake.nix                   # Optional: for development convenience
├── flake.lock                  # Generated: dependency locking
├── src/
│   ├── TaskName.hs             # Main module (public interface)
│   ├── TaskName/
│   │   ├── Types.hs            # Data types and instances
│   │   ├── Logic.hs            # Pure helper functions
│   │   └── Utils.hs            # Utility functions
└── README.md
```

## Cabal File Template

```cabal
cabal-version: 2.4
name: task-name
version: 1.0.0
synopsis: Brief description of what this task does
description: Longer description explaining the task's purpose and usage
author: Generated by LLM
license: MIT

library
  exposed-modules: TaskName
  other-modules: 
    TaskName.Types,
    TaskName.Logic,
    TaskName.Utils
  build-depends: 
    base >= 4.14,
    runix,
    runix-csv,              -- Use existing runix packages
    runix-email,
    runix-llm,
    text,
    containers
  hs-source-dirs: src
  default-language: Haskell2010
  ghc-options: -Wall
  default-extensions:
    DeriveGeneric,
    DeriveAnyClass,
    OverloadedStrings
```

## Main Module Pattern

```haskell
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE OverloadedStrings #-}

module TaskName 
  ( -- * Main Task
    taskName
  , TaskParams(..)
  , TaskResult(..)
  ) where

import Runix.Effects
import Polysemy
import Data.Text (Text)
import GHC.Generics

import TaskName.Types
import TaskName.Logic

-- | Parameters for the task
data TaskParams = TaskParams
  { paramField1 :: Text           -- ^ Description of field1
  , paramField2 :: FilePath       -- ^ Description of field2
  , paramField3 :: Maybe Int      -- ^ Optional parameter
  } deriving (Show, Read, Generic, FromJSON, ToJSON)

-- | Result of the task execution
data TaskResult = TaskResult
  { resultField1 :: Text          -- ^ Description of result
  , resultField2 :: [Text]        -- ^ List of processed items
  , resultMetadata :: TaskMetadata -- ^ Execution metadata
  } deriving (Show, Generic, ToJSON)

-- | Main task function - keep this simple and readable
taskName :: Members '[FileSystem, RestAPI] r => TaskParams -> Sem r TaskResult
taskName TaskParams{..} = do
  -- Step 1: Load input data
  inputData <- readFile (T.unpack paramField2)
  
  -- Step 2: Process using pure functions (defined in TaskName.Logic)
  let processed = processData paramField1 inputData
  
  -- Step 3: Handle optional parameters
  let finalResult = case paramField3 of
        Nothing -> processed
        Just n -> take n processed
  
  -- Step 4: Return structured result
  return $ TaskResult
    { resultField1 = "Processing complete"
    , resultField2 = finalResult
    , resultMetadata = createMetadata (length finalResult)
    }
```

## Available Effects

Use these effects in your `Members` constraint as needed:

- `FileSystem` - File operations: `readFile`, `writeFile`
- `RestAPI` - HTTP requests: `restPost`, `restGet`
- `CompileTask` - Dynamic compilation: `compileTask`, `saveProject`
- `Logging` - Structured logging: `logInfo`, `logError`, `logDebug`
- `Random` - Random number generation: `randomInt`, `randomChoice`
- `Time` - Time operations: `getCurrentTime`, `formatTime`

## Existing Task Library (Assume These Exist)

When generating tasks, assume these common modules are available and reuse them. Note that modules group related tasks that operate on similar data types:

### Data Format Modules
- `CSV.parse`, `CSV.write`, `CSV.validate`, `CSV.transform` - All CSV operations
- `JSON.decode`, `JSON.encode`, `JSON.validate`, `JSON.merge` - All JSON operations  
- `XML.parse`, `XML.transform`, `XML.validate` - All XML operations
- `Excel.readSheets`, `Excel.writeSheet`, `Excel.convertToCSV` - Excel operations

### Text Processing Module
- `TextAnalysis.extractEntities`, `TextAnalysis.summarize`, `TextAnalysis.classify`, `TextAnalysis.sentiment` - All text analysis
- `TextTransform.translate`, `TextTransform.reformat`, `TextTransform.clean` - Text transformations

### Communication Modules  
- `Email.send`, `Email.sendBulk`, `Email.validateAddresses` - Email operations
- `Slack.postMessage`, `Slack.uploadFile`, `Slack.createChannel` - Slack operations
- `Webhook.post`, `Webhook.retry`, `Webhook.validate` - Webhook operations

### File System Module
- `FileOps.download`, `FileOps.upload`, `FileOps.compress`, `FileOps.extract`, `FileOps.sync` - File operations

### Image Processing Module  
- `ImageOps.resize`, `ImageOps.convert`, `ImageOps.optimize`, `ImageOps.extractMetadata` - Image operations

### Database Module
- `Database.query`, `Database.insert`, `Database.backup`, `Database.migrate` - Database operations

### Web Operations Module
- `WebOps.scrape`, `WebOps.monitor`, `WebOps.submitForm`, `WebOps.crawl` - Web operations

## Module Design Examples

### Example 1: Document Processing Module
```haskell
module DocumentProcessing where

-- Shared data types for all document operations
data Document = Document
  { docContent :: Text
  , docMetadata :: DocumentMetadata  
  , docFormat :: DocumentFormat
  } deriving (Show, Generic, FromJSON, ToJSON)

data DocumentMetadata = DocumentMetadata
  { docTitle :: Maybe Text
  , docAuthor :: Maybe Text
  , docCreated :: Maybe UTCTime
  , docLanguage :: Maybe Language
  } deriving (Show, Generic, FromJSON, ToJSON)

-- Multiple related tasks operating on Document types
extractText :: Members '[FileSystem] r => FilePath -> Sem r Document
summarizeDocument :: Members '[LLMProcessor] r => Document -> SummaryLength -> Sem r DocumentSummary  
translateDocument :: Members '[LLMProcessor] r => Document -> Language -> Sem r Document
classifyDocument :: Members '[LLMProcessor] r => Document -> [Category] -> Sem r DocumentClassification
extractEntities :: Members '[LLMProcessor] r => Document -> [EntityType] -> Sem r [Entity]
convertFormat :: Members '[FileSystem] r => Document -> DocumentFormat -> Sem r Document
```

### Example 2: Customer Data Module  
```haskell
module CustomerData where

-- Shared customer data types
data Customer = Customer
  { customerId :: CustomerId
  , customerProfile :: CustomerProfile
  , customerHistory :: [Transaction]
  , customerPreferences :: CustomerPreferences
  } deriving (Show, Generic, FromJSON, ToJSON)

data CustomerProfile = CustomerProfile
  { profileName :: Text
  , profileEmail :: EmailAddress
  , profileSegment :: CustomerSegment
  , profileValue :: CustomerValue
  } deriving (Show, Generic, FromJSON, ToJSON)

-- Multiple tasks operating on Customer data
loadCustomerData :: Members '[Database] r => CustomerId -> Sem r Customer
analyzeCustomerBehavior :: Members '[LLMProcessor] r => Customer -> Sem r BehaviorAnalysis
segmentCustomers :: Members '[LLMProcessor] r => [Customer] -> Sem r CustomerSegmentation
generatePersonalizedContent :: Members '[LLMProcessor] r => Customer -> ContentType -> Sem r PersonalizedContent
predictCustomerChurn :: Members '[LLMProcessor] r => Customer -> Sem r ChurnPrediction
calculateCustomerLifetimeValue :: Customer -> CustomerLifetimeValue -- Pure function
```

### Example 3: Social Media Module
```haskell
module SocialMedia where

-- Shared social media data types
data SocialPost = SocialPost
  { postContent :: Text
  , postPlatform :: SocialPlatform
  , postMetadata :: PostMetadata
  , postEngagement :: Maybe EngagementMetrics
  } deriving (Show, Generic, FromJSON, ToJSON)

data SocialPlatform = Twitter | LinkedIn | Instagram | Facebook
  deriving (Show, Read, Generic, FromJSON, ToJSON)

-- Multiple tasks for social media operations
generateContent :: Members '[LLMProcessor] r => ContentPrompt -> SocialPlatform -> Sem r SocialPost
optimizeForPlatform :: SocialPost -> SocialPlatform -> SocialPost -- Pure function
schedulePost :: Members '[RestAPI] r => SocialPost -> UTCTime -> Sem r ScheduleResult
analyzeEngagement :: Members '[RestAPI, LLMProcessor] r => SocialPost -> Sem r EngagementAnalysis
moderateContent :: Members '[LLMProcessor] r => SocialPost -> Sem r ModerationResult
extractHashtags :: SocialPost -> [Hashtag] -- Pure function
```

## Task Composition Using Modules

```haskell
-- Example: Comprehensive document analysis workflow
documentAnalysisWorkflow :: Members '[FileSystem, LLMProcessor, Database] r 
                         => DocumentAnalysisParams -> Sem r DocumentAnalysisResult
documentAnalysisWorkflow DocumentAnalysisParams{..} = do
  -- Step 1: Extract document using DocumentProcessing module
  document <- DocumentProcessing.extractText inputFilePath
  
  -- Step 2: Multiple analyses using the same module
  summary <- DocumentProcessing.summarizeDocument document "medium"
  entities <- DocumentProcessing.extractEntities document ["person", "organization", "location"]
  classification <- DocumentProcessing.classifyDocument document ["legal", "financial", "technical"]
  
  -- Step 3: Use other modules for additional processing
  sentiment <- TextAnalysis.sentiment (docContent document)
  
  -- Step 4: Store results using Database module  
  _ <- Database.insert $ AnalysisRecord document summary entities classification
  
  return $ DocumentAnalysisResult summary entities classification sentiment

-- Example: Customer intelligence pipeline
customerIntelligencePipeline :: Members '[Database, LLMProcessor, Email] r
                             => CustomerIntelligenceParams -> Sem r CustomerIntelligenceResult  
customerIntelligencePipeline CustomerIntelligenceParams{..} = do
  -- Step 1: Load customer data
  customers <- mapM CustomerData.loadCustomerData customerIds
  
  -- Step 2: Multiple analyses using CustomerData module
  behaviors <- mapM CustomerData.analyzeCustomerBehavior customers
  churnPredictions <- mapM CustomerData.predictCustomerChurn customers
  segmentation <- CustomerData.segmentCustomers customers
  
  -- Step 3: Generate personalized content for each customer
  personalizedContent <- mapM (\c -> CustomerData.generatePersonalizedContent c "email_campaign") customers
  
  -- Step 4: Send emails using Email module
  emailResults <- mapM (\(customer, content) -> 
    Email.send $ EmailParams (customerEmail customer) "Personalized Offer" content
  ) (zip customers personalizedContent)
  
  return $ CustomerIntelligenceResult behaviors churnPredictions segmentation emailResults
```

## Type Design Guidelines

### Parameter Types
```haskell
-- Good: Self-documenting with validation
data EmailParams = EmailParams
  { emailRecipients :: NonEmpty EmailAddress  -- At least one recipient
  , emailSubject :: NonEmptyText              -- Subject cannot be empty
  , emailTemplate :: FilePath                 -- Path to template file
  , emailAttachments :: [FilePath]            -- Optional attachments
  } deriving (Show, Read, Generic, FromJSON, ToJSON)

-- Bad: Unclear and error-prone
data EmailParams = EmailParams
  { recipients :: [String]
  , subject :: String
  , template :: String
  , attachments :: [String]
  } deriving (Show, Read, Generic, FromJSON, ToJSON)
```

### Result Types
```haskell
-- Good: Structured with metadata
data ProcessResult = ProcessResult
  { processedItems :: [ProcessedItem]
  , processingStats :: ProcessingStats
  , warnings :: [Warning]
  , outputFiles :: [FilePath]
  } deriving (Show, Generic, ToJSON)

-- Include helpful metadata
data ProcessingStats = ProcessingStats
  { totalItems :: Int
  , successfulItems :: Int
  , failedItems :: Int
  , processingTime :: NominalDiffTime
  } deriving (Show, Generic, ToJSON)
```

## Error Handling Pattern

```haskell
-- Use Either for recoverable errors
processItem :: Item -> Either ProcessError ProcessedItem
processItem item = do
  validated <- validateItem item
  transformed <- transformItem validated
  return transformed

-- Use Maybe for optional results
findItem :: [Item] -> ItemId -> Maybe Item
findItem items itemId = find (\i -> itemId i == itemId) items

-- Let exceptions bubble up for unrecoverable errors
-- The engine will handle them appropriately
```

## Naming Conventions

### Task Names
- Use descriptive, action-oriented names: `CsvToJsonConverter`, `EmailBulkSender`
- Follow PascalCase for modules: `DataProcessor`, `ReportGenerator`
- Use camelCase for functions: `processData`, `generateReport`

### Parameter Fields
- Use descriptive prefixes: `inputFile`, `outputDirectory`, `filterCriteria`
- Make optional parameters explicit: `Maybe Int`, `[FilePath]`
- Use domain-specific types: `EmailAddress`, `URL`, `Percentage`

### Result Fields
- Use clear, descriptive names: `processedCount`, `outputFiles`, `errorMessages`
- Include metadata: `processingTime`, `warnings`, `statistics`

## Documentation Pattern

```haskell
-- | Process CSV data and generate a summary report
--
-- This task reads a CSV file, applies filtering and transformations,
-- and generates a formatted report with statistics.
--
-- Example usage:
-- @
-- result <- csvReportGenerator $ CsvReportParams
--   { csvInputFile = "data.csv"
--   , csvFilterRules = [ColumnGreaterThan "age" 18]
--   , csvReportTemplate = "report.html.template"
--   }
-- @
csvReportGenerator :: Members '[FileSystem] r => CsvReportParams -> Sem r CsvReportResult
```

## Testing Considerations

Include example usage in your documentation:

```haskell
-- Example in module documentation:
-- 
-- >>> let params = TaskParams "input.txt" "output.txt" (Just 10)
-- >>> result <- runTask params
-- >>> resultField1 result
-- "Processing complete"
```

## Common Patterns to Follow

1. **Input Validation**: Validate parameters early and fail fast
2. **Pure Core**: Keep business logic in pure functions
3. **Effect Isolation**: Use effects only for I/O operations
4. **Composability**: Design tasks to work well with others
5. **Error Context**: Provide meaningful error messages

## Anti-Patterns to Avoid

1. **Monolithic Functions**: Don't put all logic in the main task function
2. **Stringly Typed**: Use proper types instead of raw strings
3. **Hidden Dependencies**: Make all requirements explicit in the type signature
4. **Side Effects in Pure Code**: Keep pure functions pure
5. **Unclear Interfaces**: Avoid ambiguous parameter names

## Template for New Tasks

When generating a new task, start with this template and fill in the specifics:

```haskell
module NewTaskName 
  ( newTaskName
  , NewTaskParams(..)
  , NewTaskResult(..)
  ) where

import Runix.Effects
import Polysemy
import Data.Text (Text)
import GHC.Generics

-- | Parameters for [describe what the task does]
data NewTaskParams = NewTaskParams
  { -- Add parameters here with documentation
  } deriving (Show, Read, Generic, FromJSON, ToJSON)

-- | Result of [describe what the task produces]
data NewTaskResult = NewTaskResult
  { -- Add result fields here with documentation
  } deriving (Show, Generic, ToJSON)

-- | [Brief description of what this task does]
--
-- [Longer description with examples]
newTaskName :: Members '[RequiredEffects] r => NewTaskParams -> Sem r NewTaskResult
newTaskName params = do
  -- Implementation here
  undefined
```

Remember: The goal is to create tasks that are easy to understand, compose, and maintain. Prioritize clarity and type safety over clever implementations.
